{
    "collab_server" : "",
    "contents" : "\nrequire(ggplot2)\nrequire(gridExtra)\nrequire(RColorBrewer)\nrequire(pracma)\nrequire(scales)\n\n\n#' Descripción de la función\n#' @param\n#' @return\n#'\n#' @export\n\nget.mfARI <- function(Ks, Delta.tau, Phi)\n{\n  #\n  # From regression on bounded mfARI parameters made\n  # on mar 06 2015\n  #\n  # Call:\n  # lm(formula = ATARI ~ Ks + Delta.tau + Phi, data = params)\n  #\n  # Residuals:\n  #      Min       1Q   Median       3Q      Max\n  # -0.24540 -0.08135  0.01454  0.07764  0.19562\n  #\n  # Coefficients:\n  #             Estimate Std. Error t value Pr(>|t|)\n  # (Intercept)  1.48740    0.31454   4.729 8.65e-06 ***\n  # Ks           3.85688    0.11339  34.014  < 2e-16 ***\n  # Delta.tau   -0.12420    0.02910  -4.269 4.99e-05 ***\n  # Phi          0.10999    0.00608  18.091  < 2e-16 ***\n  # ---\n  # Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n  #\n  # Residual standard error: 0.1161 on 87 degrees of freedom\n  # Multiple R-squared:  0.9981,\tAdjusted R-squared:  0.9981\n  # F-statistic: 1.55e+04 on 3 and 87 DF,  p-value: < 2.2e-16\n\n  invisible(1.48740 + 3.85688 * Ks - 0.12420 * Delta.tau + 0.10999 * Phi)\n}\n\n#' Descripción de la función\n#' @param\n#' @return\n#'\n#' @export\n#'\nget.mfARI.no.Phi <- function(Ks, Delta.tau)\n{\n  # From regression on bounded mfARI parameters (discarding Phi)\n  # made on mar 10 2015\n  #\n  # Call:\n  # lm(formula = ATARI ~ Ks + Delta.tau, data = params)\n  #\n  # Residuals:\n  #      Min       1Q   Median       3Q      Max\n  # -0.56369 -0.15209 -0.03217  0.16018  0.60636\n  #\n  # Coefficients:\n  #             Estimate Std. Error t value Pr(>|t|)\n  # (Intercept)  6.75148    0.25915   26.05   <2e-16 ***\n  # Ks           2.51501    0.18608   13.52   <2e-16 ***\n  # Delta.tau   -0.61895    0.02155  -28.72   <2e-16 ***\n  # ---\n  # Signif. codes:  0 ‘***’ 0.001 ‘**’ 0.01 ‘*’ 0.05 ‘.’ 0.1 ‘ ’ 1\n  #\n  # Residual standard error: 0.2519 on 88 degrees of freedom\n  # Multiple R-squared:  0.9911,\tAdjusted R-squared:  0.9909\n  # F-statistic:  4904 on 2 and 88 DF,  p-value: < 2.2e-16\n\n  invisible(6.75148 + 2.51501 * Ks - 0.61895 * Delta.tau)\n}\n\n\n#' Descripción de la función\n#' @param\n#' @return Returns a plot with the CBFV parameters for a specific Delta-Tau.\n#'\n#' @export\nget.plot.CBFV.parameters.search <- function(\n      time.instants,\n      normalised.CBFV.signal,\n      min.CBFV.sample,\n      min.CBFV.time.instant,\n      search.results,\n      cbfv.palette = brewer.pal(n = 9, name = \"Blues\"),\n      id = NULL,\n      ...\n      )\n{\n  ymin <- min(normalised.CBFV.signal)\n  ymax <- max(normalised.CBFV.signal)\n  dy <- (ymax - ymin) / 100\n  dx <- (tail(time.instants, 1) - time.instants[1]) / 100\n\n  # Plots CBFV\n  d <- data.frame(Time = time.instants, CBFV = normalised.CBFV.signal)\n  p <- ggplot(data = d, mapping = aes(x = Time, y = CBFV))\n  p <- p + geom_line(colour = cbfv.palette[4])\n  p <- p + geom_point(colour = cbfv.palette[4])\n\n  # If a transient and a steady CBFV were found\n  if(is.finite(search.results[[\"CBFV.response.MSE\"]]))\n  {\n    # Plots transient CBFV line\n    dtl <- data.frame(\n      Time = search.results[[\"transient.CBFV.time.instants\"]],\n      CBFV = search.results[[\"transient.CBFV.line\"]]\n    )\n    p <- p + geom_line(data = dtl, colour = cbfv.palette[7])\n\n    # Plots initial and final points of the transient CBFV\n    dti <- data.frame(\n      Time = search.results[[\"transient.CBFV.time.instants\"]][1],\n      CBFV = search.results[[\"transient.normalised.CBFV.signal\"]][1]\n    )\n    p <- p + geom_point(data = dti, colour = cbfv.palette[7])\n    dtf <- data.frame(\n      Time = tail(search.results[[\"transient.CBFV.time.instants\"]], 1),\n      CBFV = tail(search.results[[\"transient.normalised.CBFV.signal\"]], 1)\n    )\n    p <- p + geom_point(data = dtf, colour = cbfv.palette[7])\n\n    # Adds time annotations\n    d <- dti\n    d[[\"CBFV\"]] <- d[[\"CBFV\"]] - 2 * dy\n    d <- cbind(d, Text = sprintf(\"%.1f\", min.CBFV.time.instant))\n    p <- p + geom_text(\n      data = d,\n      mapping = aes(label = Text),\n      colour = cbfv.palette[7],\n      size = 2,\n      hjust = 0.5,\n      vjust = 1\n    )\n    d <- dtf\n    u <- ifelse(dti[[\"CBFV\"]] < dtf[[\"CBFV\"]], -2 * dy, 3 * dy)\n    d[[\"CBFV\"]] <- dti[[\"CBFV\"]] + u\n    d <- cbind(d, Text = sprintf(\"%.1f\", search.results[[\"tau\"]]))\n    p <- p + geom_text(\n      data = d,\n      mapping = aes(label = Text),\n      colour = cbfv.palette[7],\n      size = 2,\n      hjust = 0.5,\n      vjust = 1\n    )\n    d <- dtf\n    d[[\"Time\"]] <- d[[\"Time\"]] - dx\n    u <- ifelse(dti[[\"CBFV\"]] < dtf[[\"CBFV\"]], 2 * dy, -3 * dy)\n    d[[\"CBFV\"]] <- d[[\"CBFV\"]] + u\n    d <- cbind(d, Text = \"Tau\")\n    p <- p + geom_text(\n      data = d,\n      mapping = aes(label = Text),\n      colour = cbfv.palette[7],\n      size = 2,\n      hjust = 0.5,\n      vjust = 0\n    )\n\n    # Adds lines to annotations\n    d <- rbind(dtf, dtf)\n    d[[\"CBFV\"]][2] <- dti[[\"CBFV\"]]\n    p <- p + geom_line(\n      data = d,\n      colour = cbfv.palette[7],\n      linetype = \"dashed\"\n    )\n\n    # Plots steady CBFV\n    dsl <- data.frame(\n      Time = search.results[[\"steady.CBFV.time.instants\"]],\n      CBFV = search.results[[\"steady.CBFV.line\"]]\n    )\n    p <- p + geom_line(data = dsl, colour = cbfv.palette[7])\n\n    # Adds time annotations\n    d <- tail(dsl, 1)\n    u <- ifelse(dti[[\"CBFV\"]] < dtf[[\"CBFV\"]], -2 * dy, 3 * dy)\n    d[[\"CBFV\"]] <- dti[[\"CBFV\"]] + u\n    s <- sprintf(\"%.1f\", d[[\"Time\"]])\n    d <- cbind(d, Text = s)\n    p <- p + geom_text(\n      data = d,\n      mapping = aes(label = Text),\n      colour = cbfv.palette[7],\n      size = 2,\n      hjust = 0.5,\n      vjust = 1\n    )\n\n    # Adds lines to annotations\n    u <- ifelse(dti[[\"CBFV\"]] < dtf[[\"CBFV\"]], 2 * dy, -3 * dy)\n    d[[\"CBFV\"]] <- d[[\"CBFV\"]] + u\n    d <- rbind(d[, c(1, 2)], tail(dsl, 1))\n    p <- p + geom_line(\n      data = d,\n      colour = cbfv.palette[7],\n      linetype = \"dashed\"\n    )\n\n    # Adds summary table\n    s <- sprintf(\"%.1fs\", search.results[[\"Delta.tau\"]])\n    t <- data.frame(l = \"Delta Tau\", d = s)\n    s <- sprintf(\"%.3f\", search.results[[\"Ks\"]])\n    t <- rbind(t, data.frame(l = \"Ks\", d = s))\n    s <- sprintf(\"%.2f°\",\n      atan(search.results[[\"transient.CBFV.slope\"]]) * 180 / pi\n    )\n    t <- rbind(t, data.frame(l = \"Angle\", d = s))\n    s <- sprintf(\"%.4f\", search.results[[\"transient.CBFV.MSE\"]])\n    t <- rbind(t, data.frame(l = \"Trans. MSE\", d = s))\n    s <- sprintf(\"%.4f\", search.results[[\"steady.CBFV.MSE\"]])\n    t <- rbind(t, data.frame(l = \"Steady MSE\", d = s))\n    s <- sprintf(\"%.4f\", search.results[[\"CBFV.response.MSE\"]])\n    t <- rbind(t, data.frame(l = \"Total MSE\", d = s))\n\n    gt <- tableGrob(\n      d = t,\n      show.rownames = FALSE,\n      show.colnames = FALSE,\n      gpar.coretext = gpar(col = cbfv.palette[7], cex = 0.5),\n      padding.v = unit(2, \"mm\")\n    )\n    p <- p + annotation_custom(\n      grob = gt,\n      xmin = time.instants[1],\n      xmax = time.instants[1] + 9,\n      ymin = ymin,\n      ymax = ymin + 25 * dy\n    )\n  }\n\n  if(!is.null(id))\n    p <- p + ggtitle(id)\n  p <- p + xlab(\"Time\") + ylab(\"Normalised CBFV\")\n\n  p\n}\n\n\n#' Descripción de la función\n#' @param\n#' @return Returns a plot with the CBFV parameters for a specific Delta-Tau.\n#'\n#' @export\n\nget.plots.mfARI.parameters <- function(\n      time.instants,\n      ABP.signal,\n      CBFV.signal,\n      parameter.results,\n      index.estimation.function = NULL,\n      abp.palette = brewer.pal(n = 9, name = \"Reds\"),\n      cbfv.palette = brewer.pal(n = 9, name = \"Blues\"),\n      ann.palette = brewer.pal(n = 9, name = \"Greens\")[seq(3, 9, 2)],\n      time.tol = min(diff(time.instants)) / 100,\n      id = NULL,\n      ...\n      )\n{\n  #\n  # Plot 1 (original signals)\n  #\n\n  abp.ymin <- min(ABP.signal, na.rm = TRUE)\n  abp.ymax <- max(ABP.signal, na.rm = TRUE)\n  abp.ry <- abp.ymax - abp.ymin\n  abp.dy <- abp.ry / 100\n\n  cbfv.ymin <- min(CBFV.signal, na.rm = TRUE)\n  cbfv.ymax <- max(CBFV.signal, na.rm = TRUE)\n  cbfv.ry <- cbfv.ymax - cbfv.ymin\n  cbfv.dy <- cbfv.ry / 100\n\n  rx <- tail(time.instants, 1) - time.instants[1]\n  dx <- rx / 100\n\n  # Plots ABP\n  dabp <- data.frame(\n    Time = time.instants,\n    Signal = ABP.signal,\n    Segment = \"ABP Signal\"\n  )\n  p1 <- ggplot(\n    data = dabp,\n    mapping = aes(x = Time, y = Signal, colour = Segment)\n  )\n  p1 <- p1 + geom_line(linetype = \"dashed\")\n\n  # Plots CBFV\n  dcbfv <- data.frame(\n    Time = time.instants,\n    Signal = CBFV.signal,\n    Segment = \"CBFV Signal\"\n  )\n  p2 <- ggplot(\n    data = dabp,\n    mapping = aes(x = Time, y = Signal, colour = Segment)\n  )\n  p2 <- p2 + geom_line(data = dcbfv, linetype = \"dashed\")\n\n  # Plots ABP baseline\n  d <- dabp[parameter.results[[\"ABP.baseline.samples\"]], ]\n  d[[\"Segment\"]] <- \"Baseline\"\n  p1 <- p1 + geom_point(data = d)\n  d[[\"Signal\"]] <- parameter.results[[\"ABP.baseline.value\"]]\n  p1 <- p1 + geom_line(data = d)\n\n  # Plots CBFV baseline\n  d <- dcbfv[parameter.results[[\"CBFV.baseline.samples\"]], ]\n  d[[\"Segment\"]] <- \"Baseline\"\n  p2 <- p2 + geom_point(data = d)\n  d[[\"Signal\"]] <- parameter.results[[\"CBFV.baseline.value\"]]\n  p2 <- p2 + geom_line(data = d)\n\n  # Plots min ABP window\n  d <- dabp[parameter.results[[\"min.ABP.samples\"]], ]\n  d[[\"Segment\"]] <- \"Min. Search Window\"\n  p1 <- p1 + geom_point(data = d)\n  d[[\"Signal\"]] <- parameter.results[[\"min.ABP.value\"]]\n  p1 <- p1 + geom_line(data = d, linetype = \"dashed\")\n\n  # Plots min CBFV window\n  d <- dcbfv[parameter.results[[\"min.CBFV.samples\"]], ]\n  d[[\"Segment\"]] <- \"Min. Search Window\"\n  p2 <- p2 + geom_point(data = d)\n\n  # Adds min ABP time annotation\n  d <- dabp[parameter.results[[\"min.ABP.sample\"]], ]\n  d[[\"Signal\"]] <- d[[\"Signal\"]] - 2 * abp.dy\n  d[[\"Segment\"]] <- \"Min. Search Window\"\n  d <- cbind(d, Text = sprintf(\"%.1f\", d[[\"Time\"]]))\n  p1 <- p1 + geom_text(\n    data = d,\n    mapping = aes(label = Text),\n    size = 3,\n    hjust = 0.5,\n    vjust = 1\n  )\n\n  # Adds min CBFV time annotation\n  d <- dcbfv[parameter.results[[\"min.CBFV.sample\"]], ]\n  d[[\"Signal\"]] <- d[[\"Signal\"]] - 2 * cbfv.dy\n  d[[\"Segment\"]] <- \"Min. Search Window\"\n  d <- cbind(d, Text = sprintf(\"%.1f\", d[[\"Time\"]]))\n  p2 <- p2 + geom_text(\n    data = d,\n    mapping = aes(label = Text),\n    size = 3,\n    hjust = 0.5,\n    vjust = 1\n  )\n\n  # Adds min ABP drop annotation\n  d <- dabp[parameter.results[[\"min.ABP.samples\"]][1], ]\n  d[[\"Segment\"]] <- \"Min. Search Window\"\n  d[[\"Signal\"]] <- parameter.results[[\"min.ABP.value\"]] - 4 * cbfv.dy\n  d <- cbind(\n    d,\n    Text = sprintf(\"%.1f%% drop\", parameter.results[[\"min.ABP.drop.pc\"]])\n  )\n  p1 <- p1 + geom_text(\n    data = d,\n    mapping = aes(label = Text),\n    size = 2,\n    hjust = 0.5,\n    vjust = 1\n  )\n\n  p1 <- p1 + xlab(\"Time\") + ylab(\"ABP\")\n  p2 <- p2 + xlab(\"Time\") + ylab(\"CBFV\")\n  cmatch1 <- c(\n    \"ABP Signal\" = abp.palette[4],\n    \"CBFV Signal\" = cbfv.palette[4],\n    \"Baseline\" = ann.palette[2],\n    \"Min. Search Window\" = ann.palette[3]\n  )\n  p1 <- p1 + scale_colour_manual(values = cmatch1, breaks = names(cmatch1))\n  p2 <- p2 + scale_colour_manual(values = cmatch1, breaks = names(cmatch1))\n  p1 <- p1 + theme(\n    legend.justification = c(1, 1),\n    legend.background = element_rect(fill = alpha('grey90', 0.0)),\n    legend.position = c(1, 1),\n    legend.key.size =  unit(0.3, \"cm\"),\n    legend.title = element_text(size = 7),\n    legend.text = element_text(size = 6)\n  )\n  p2 <- p2 + theme(\n    legend.justification = c(1, 1),\n    legend.background = element_rect(fill = alpha('grey90', 0.0)),\n    legend.position = c(1, 1),\n    legend.key.size =  unit(0.4, \"cm\"),\n    legend.title = element_text(size = 7),\n    legend.text = element_text(size = 6)\n  )\n\n  #\n  # Plot 3 (normalised signals)\n  #\n\n  ABP.time <- time.instants -\n              time.instants[parameter.results[[\"min.ABP.sample\"]]]\n  ABP.signal <- parameter.results[[\"normalised.ABP.signal\"]]\n\n  CBFV.time <- time.instants -\n               time.instants[parameter.results[[\"min.CBFV.sample\"]]]\n  CBFV.signal <- parameter.results[[\"normalised.CBFV.signal\"]]\n\n  xmin <- min(c(ABP.time, CBFV.time))\n  xmax <- max(c(ABP.time, CBFV.time))\n  rx <- xmax - xmin\n  dx <- rx / 100\n  ymin <- min(c(ABP.signal, CBFV.signal))\n  ymax <- max(c(ABP.signal, CBFV.signal))\n  ry <- ymax - ymin\n  dy <- ry / 100\n\n  # Plots CBFV\n  dcbfv <- data.frame(\n    Time = CBFV.time,\n    Signal = CBFV.signal,\n    Segment = \"Normalised CBFV\"\n  )\n  p3 <- ggplot(\n    data = dcbfv,\n    mapping = aes(x = Time, y = Signal, colour = Segment)\n  )\n  d <- dcbfv[1:(parameter.results[[\"transient.CBFV.samples\"]][1]), ]\n  p3 <- p3 + geom_line(data = d, linetype = \"dashed\")\n  r <- tail(parameter.results[[\"transient.CBFV.samples\"]], 1)\n  d <- dcbfv[r:nrow(dcbfv), ]\n  p3 <- p3 + geom_line(data = d, linetype = \"dashed\")\n\n  # Plots ABP\n  dabp <- data.frame(\n    Time = ABP.time,\n    Signal = ABP.signal,\n    Segment = \"Normalised ABP\"\n  )\n  d <- dabp[1:(parameter.results[[\"transient.ABP.samples\"]][1]), ]\n  p3 <- p3 + geom_line(data = d, linetype = \"dashed\")\n  r <- tail(parameter.results[[\"transient.ABP.samples\"]], 1)\n  d <- dabp[r:nrow(dabp), ]\n  p3 <- p3 + geom_line(data = d, linetype = \"dashed\")\n\n  # Plots ABP transient segment\n  d <- dabp[parameter.results[[\"transient.ABP.samples\"]], ]\n  p3 <- p3 + geom_line(data = d, linetype = \"11\")\n  d[[\"Signal\"]] <- parameter.results[[\"transient.ABP.line\"]]\n  d[[\"Segment\"]] <- \"Transient Line\"\n  p3 <- p3 + geom_line(data = d)\n\n  # Plots CBFV transient segment\n  d <- dcbfv[parameter.results[[\"transient.CBFV.samples\"]], ]\n  p3 <- p3 + geom_line(data = d, linetype = \"11\")\n  d[[\"Signal\"]] <- parameter.results[[\"transient.CBFV.line\"]]\n  d[[\"Segment\"]] <- \"Transient Line\"\n  p3 <- p3 + geom_line(data = d)\n\n  # Plots CBFV steady segment\n  d <- dcbfv[parameter.results[[\"steady.CBFV.samples\"]], ]\n  d[[\"Signal\"]] <- parameter.results[[\"steady.CBFV.line\"]]\n  d[[\"Segment\"]] <- \"Steady Line\"\n  p3 <- p3 + geom_line(data = d, linetype = \"dashed\")\n\n  # Plots and annotates Delta Tau\n  s2 <- parameter.results[[\"transient.CBFV.samples\"]]\n  d2 <- dcbfv[s2, ]\n  y <- min(d2[[\"Signal\"]], na.rm = TRUE)\n  tini2 <- CBFV.time[s2[1]]\n  tfin2 <- CBFV.time[tail(s2, 1)]\n  tini1 <- ABP.time > tini2 - time.tol\n  tfin1 <- ABP.time < tfin2 + time.tol\n  s1 <- which(tini1 & tfin1)\n  d1 <- dabp[s1, ]\n  y <- min(c(d1[[\"Signal\"]], y), na.rm = TRUE)\n\n  d2[[\"Signal\"]] <- y - 2 * dy\n  d2[[\"Segment\"]] <- \"Transient Line\"\n  p3 <- p3 + geom_line(data = d2)\n  m <- round(nrow(d2) / 2)\n  d <- d2[m, ]\n  d[[\"Signal\"]] <- d[[\"Signal\"]] - dy\n  s <- paste(\n    \"Delta*tau\",\n    \"==\",\n    sprintf(\"%.1f\", parameter.results[[\"Delta.tau\"]])\n  )\n  d <- cbind(d, Text = s)\n  p3 <- p3 + geom_text(\n    data = d,\n    mapping = aes(label = Text),\n    size = 3,\n    hjust = 0.4,\n    vjust = 1,\n    parse = TRUE\n  )\n\n  # Annotates Ks\n  d2 <- dcbfv[parameter.results[[\"steady.CBFV.samples\"]], ]\n  i <- d2[[\"Signal\"]] < parameter.results[[\"Ks\"]]\n  d2[[\"Signal\"]] <- parameter.results[[\"Ks\"]]\n  d2[[\"Segment\"]] <- \"Steady Line\"\n  p3 <- p3 + geom_line(data = d2)\n  u <- 2 * dy\n  vjust <- 0\n  if(sum(i) - sum(!i) < 0)\n  {\n    u <- -u\n    vjust <- 1 - vjust\n  }\n  m <- round(nrow(d2) / 2)\n  d <- d2[m, ]\n  d[[\"Signal\"]] <- d[[\"Signal\"]] + u\n  s <- paste(\"K[s]\", \"==\", sprintf(\"%.4f\", parameter.results[[\"Ks\"]]))\n  d <- cbind(d, Text = s)\n  p3 <- p3 + geom_text(\n    data = d,\n    mapping = aes(label = Text),\n    size = 3,\n    hjust = 0.5,\n    vjust = vjust,\n    parse = TRUE\n  )\n\n  # Plots and annotates Phi\n  if(!is.null(ABP.signal))\n  {\n    d1 <- dabp[parameter.results[[\"transient.ABP.samples\"]], ]\n    d1[[\"Signal\"]] <- parameter.results[[\"transient.ABP.line\"]]\n    d2 <- dcbfv[parameter.results[[\"transient.CBFV.samples\"]], ]\n    d2[[\"Signal\"]] <- parameter.results[[\"transient.CBFV.line\"]]\n    m <- round(min(nrow(d1), nrow(d2)) * 0.8)\n    #d <- rbind(d1[m, ], d2[m, ])\n    #d[[\"Segment\"]] <- \"Angle\"\n    #p3 <- p3 + geom_point(data = d)\n    r <- d1[[\"Time\"]][m]\n    tt <- seq(-90, 90, length.out = 100)\n    xx <- r * cos(tt * pi / 180)\n    yy <- (sin(tt * pi / 180) + 1) / 2\n    yy <- sin(tt * pi / 180)\n    #d <- data.frame(Time = xx, Signal = yy, Segment = \"Angle\")\n    #p3 <- p3 + geom_path(data = d, linetype = \"dotted\")\n    .dist <- function(x, y) sqrt((x - xx)^2 + (y - yy)^2)\n    .tmp.fun <- function(x, y) min(.dist(x, y))\n    s1 <- mapply(.tmp.fun, d1[[\"Time\"]], d1[[\"Signal\"]])\n    s1 <- which.min(s1)\n    s2 <- mapply(.tmp.fun, d2[[\"Time\"]], d2[[\"Signal\"]])\n    s2 <- which.min(s2)\n    t1 <- ABP.time[parameter.results[[\"transient.ABP.samples\"]][s1]]\n    t2 <- CBFV.time[parameter.results[[\"transient.CBFV.samples\"]][s2]]\n    y1 <- parameter.results[[\"transient.ABP.line\"]][s1]\n    y2 <- parameter.results[[\"transient.CBFV.line\"]][s2]\n    d <- data.frame(Time = c(t1, t2), Signal = c(y1, y2), Segment = \"BLA\")\n    #p3 <- p3 + geom_point(data = d)\n    i <- yy < max(y1, y2)\n    j <- yy > min(y1, y2)\n    if(sum(i & j) > 0)\n    {\n      d <- data.frame(\n        Time = xx[i & j],\n        Signal = yy[i & j],\n        Segment = \"Angle\"\n      )\n      p3 <- p3 + geom_path(data = d, linetype = \"11\")\n    }\n\n    i <- yy < max(y1, y2) & yy < 1\n    j <- yy > min(y1, y2) & yy > 0\n    if(sum(i & j) > 0)\n    {\n      xx <- xx[i & j]\n      yy <- yy[i & j]\n      d <- data.frame(Time = xx, Signal = yy, Segment = \"Angle\")\n      p3 <- p3 + geom_path(data = d)\n    }\n    m <- round(nrow(d) / 2)\n    d <- d[m, ]\n    d[[\"Time\"]] <- d[[\"Time\"]] + dx\n    d[[\"Segment\"]] <- \"Angle\"\n    s <- paste(\n      \"varphi\",\n      \"==\",\n      sprintf(\"%.2f*degree\", parameter.results[[\"Phi\"]])\n    )\n    d <- cbind(d, Text = s)\n    p3 <- p3 + geom_text(\n      data = d,\n      mapping = aes(label = Text),\n      size = 3,\n      hjust = 0,\n      vjust = 0.5,\n      parse = TRUE\n    )\n  }\n\n  p3 <- p3 + xlab(\"Time\") + ylab(\"Normalised Signals\")\n  cmatch2 <- c(\n    \"Normalised ABP\" = abp.palette[4],\n    \"Normalised CBFV\" = cbfv.palette[4],\n    \"Transient Line\" = ann.palette[2],\n    \"Steady Line\" = ann.palette[3],\n    \"Angle\" = ann.palette[4]\n  )\n  p3 <- p3 + scale_colour_manual(\n    values = cmatch2,\n    breaks = names(cmatch2)\n  )\n  p3 <- p3 + theme(\n    legend.justification = c(0, 0),\n    legend.background = element_rect(fill = alpha('grey90', 0.0)),\n    legend.position = c(0, 0),\n    legend.key.size =  unit(0.4, \"cm\"),\n    legend.title = element_text(size = 7),\n    legend.text = element_text(size = 6)\n  )\n\n  #\n  # Joins plots\n  #\n\n  main <- NULL\n  if(!is.null(parameter.results[[\"mfARI\"]]))\n    main <- sprintf(\"mfARI = %.1f\", parameter.results[[\"mfARI\"]])\n  else\n    if(!is.null(index.estimation.function))\n    {\n      mfari <- index.estimation.function(\n        Ks = parameter.results[[\"Ks\"]],\n        Delta.tau = parameter.results[[\"Delta.tau\"]],\n        Phi = parameter.results[[\"Phi\"]]\n      )\n      main <- sprintf(\"estimated mfARI = %.1f\", mfari)\n    }\n\n  if(!is.null(id))\n    if(is.null(main))\n      main <- id\n    else\n      main <- paste(id, main, sep = \", \")\n\n  p <- arrangeGrob(\n    arrangeGrob(p1, p2, nrow = 2),\n    p3,\n    nrow = 2,\n    main = main\n  )\n\n  p\n}\n\n#' Descripción de la función\n#' @param\n#' @return\n#'\n#' @export\n\nget.plots.mfARI.parameters.fixed.coord <- function(\n      time.instants,\n      ABP.signal,\n      CBFV.signal,\n      parameter.results,\n      time.until.min,\n      time.after.min,\n      min.normalised.intensity,\n      max.normalised.intensity,\n      index.estimation.function = NULL,\n      abp.palette = brewer.pal(n = 9, name = \"Reds\"),\n      cbfv.palette = brewer.pal(n = 9, name = \"Blues\"),\n      ann.palette = brewer.pal(n = 9, name = \"Greens\")[seq(3, 9, 2)],\n      time.tol = min(diff(time.instants)) / 100,\n      id = NULL,\n      ...\n      )\n{\n  #\n  # Plot 1 (original signals)\n  #\n\n  abp.ymin <- min(ABP.signal, na.rm = TRUE)\n  abp.ymax <- max(ABP.signal, na.rm = TRUE)\n  abp.ry <- abp.ymax - abp.ymin\n  abp.dy <- abp.ry / 100\n\n  cbfv.ymin <- min(CBFV.signal, na.rm = TRUE)\n  cbfv.ymax <- max(CBFV.signal, na.rm = TRUE)\n  cbfv.ry <- cbfv.ymax - cbfv.ymin\n  cbfv.dy <- cbfv.ry / 100\n\n  rx <- tail(time.instants, 1) - time.instants[1]\n  dx <- rx / 100\n\n  # Plots ABP\n  dabp <- data.frame(\n    Time = time.instants,\n    Signal = ABP.signal,\n    Segment = \"ABP Signal\"\n  )\n  p1 <- ggplot(\n    data = dabp,\n    mapping = aes(x = Time, y = Signal, colour = Segment)\n  )\n  p1 <- p1 + geom_line(linetype = \"dashed\")\n\n  # Plots CBFV\n  dcbfv <- data.frame(\n    Time = time.instants,\n    Signal = CBFV.signal,\n    Segment = \"CBFV Signal\"\n  )\n  p2 <- ggplot(\n    data = dabp,\n    mapping = aes(x = Time, y = Signal, colour = Segment)\n  )\n  p2 <- p2 + geom_line(data = dcbfv, linetype = \"dashed\")\n\n  # Plots ABP baseline\n  d <- dabp[parameter.results[[\"ABP.baseline.samples\"]], ]\n  d[[\"Segment\"]] <- \"Baseline\"\n  p1 <- p1 + geom_point(data = d)\n  d[[\"Signal\"]] <- parameter.results[[\"ABP.baseline.value\"]]\n  p1 <- p1 + geom_line(data = d)\n\n  # Plots CBFV baseline\n  d <- dcbfv[parameter.results[[\"CBFV.baseline.samples\"]], ]\n  d[[\"Segment\"]] <- \"Baseline\"\n  p2 <- p2 + geom_point(data = d)\n  d[[\"Signal\"]] <- parameter.results[[\"CBFV.baseline.value\"]]\n  p2 <- p2 + geom_line(data = d)\n\n  # Plots min ABP window\n  d <- dabp[parameter.results[[\"min.ABP.samples\"]], ]\n  d[[\"Segment\"]] <- \"Min. Search Window\"\n  p1 <- p1 + geom_point(data = d)\n  d[[\"Signal\"]] <- parameter.results[[\"min.ABP.value\"]]\n  p1 <- p1 + geom_line(data = d, linetype = \"dashed\")\n\n  # Plots min CBFV window\n  d <- dcbfv[parameter.results[[\"min.CBFV.samples\"]], ]\n  d[[\"Segment\"]] <- \"Min. Search Window\"\n  p2 <- p2 + geom_point(data = d)\n\n  # Adds min ABP time annotation\n  d <- dabp[parameter.results[[\"min.ABP.sample\"]], ]\n  d[[\"Signal\"]] <- d[[\"Signal\"]] - 2 * abp.dy\n  d[[\"Segment\"]] <- \"Min. Search Window\"\n  d <- cbind(d, Text = sprintf(\"%.1f\", d[[\"Time\"]]))\n  p1 <- p1 + geom_text(\n    data = d,\n    mapping = aes(label = Text),\n    size = 3,\n    hjust = 0.5,\n    vjust = 1\n  )\n\n  # Adds min CBFV time annotation\n  d <- dcbfv[parameter.results[[\"min.CBFV.sample\"]], ]\n  d[[\"Signal\"]] <- d[[\"Signal\"]] - 2 * cbfv.dy\n  d[[\"Segment\"]] <- \"Min. Search Window\"\n  d <- cbind(d, Text = sprintf(\"%.1f\", d[[\"Time\"]]))\n  p2 <- p2 + geom_text(\n    data = d,\n    mapping = aes(label = Text),\n    size = 3,\n    hjust = 0.5,\n    vjust = 1\n  )\n\n  # Adds min ABP drop annotation\n  d <- dabp[parameter.results[[\"min.ABP.samples\"]][1], ]\n  d[[\"Segment\"]] <- \"Min. Search Window\"\n  d[[\"Signal\"]] <- parameter.results[[\"min.ABP.value\"]] - 4 * cbfv.dy\n  d <- cbind(\n    d,\n    Text = sprintf(\"%.1f%% drop\", parameter.results[[\"min.ABP.drop.pc\"]])\n  )\n  p1 <- p1 + geom_text(\n    data = d,\n    mapping = aes(label = Text),\n    size = 2,\n    hjust = 0.5,\n    vjust = 1\n  )\n\n  p1 <- p1 + xlab(\"Time\") + ylab(\"ABP\")\n  p2 <- p2 + xlab(\"Time\") + ylab(\"CBFV\")\n  cmatch1 <- c(\n    \"ABP Signal\" = abp.palette[4],\n    \"CBFV Signal\" = cbfv.palette[4],\n    \"Baseline\" = ann.palette[2],\n    \"Min. Search Window\" = ann.palette[3]\n  )\n  p1 <- p1 + scale_colour_manual(values = cmatch1, breaks = names(cmatch1))\n  p2 <- p2 + scale_colour_manual(values = cmatch1, breaks = names(cmatch1))\n  p1 <- p1 + theme(\n    legend.justification = c(1, 1),\n    legend.background = element_rect(fill = alpha('grey90', 0.0)),\n    legend.position = c(1, 1),\n    legend.key.size =  unit(0.3, \"cm\"),\n    legend.title = element_text(size = 7),\n    legend.text = element_text(size = 6)\n  )\n  p2 <- p2 + theme(\n    legend.justification = c(1, 1),\n    legend.background = element_rect(fill = alpha('grey90', 0.0)),\n    legend.position = c(1, 1),\n    legend.key.size =  unit(0.4, \"cm\"),\n    legend.title = element_text(size = 7),\n    legend.text = element_text(size = 6)\n  )\n\n  #\n  # Plot 3 (normalised signals)\n  #\n\n  ABP.time <- time.instants -\n              time.instants[parameter.results[[\"min.ABP.sample\"]]]\n  ABP.signal <- parameter.results[[\"normalised.ABP.signal\"]]\n\n  CBFV.time <- time.instants -\n               time.instants[parameter.results[[\"min.CBFV.sample\"]]]\n  CBFV.signal <- parameter.results[[\"normalised.CBFV.signal\"]]\n\n  time.ini <- 0 - time.until.min - time.tol\n  time.fin <- 0 + time.after.min + time.tol\n\n  rx <- time.fin - time.ini\n  dx <- rx / 100\n  ry <- max.normalised.intensity - min.normalised.intensity\n  dy <- ry / 100\n\n  # Plots CBFV\n  dcbfv <- data.frame(\n    Time = CBFV.time,\n    Signal = CBFV.signal,\n    Segment = \"Normalised CBFV\"\n  )\n  p3 <- ggplot(\n    data = dcbfv,\n    mapping = aes(x = Time, y = Signal, colour = Segment)\n  )\n  d <- dcbfv[1:(parameter.results[[\"transient.CBFV.samples\"]][1]), ]\n  p3 <- p3 + geom_line(data = d, linetype = \"dashed\")\n  r <- tail(parameter.results[[\"transient.CBFV.samples\"]], 1):nrow(dcbfv)\n  d <- dcbfv[r, ]\n  p3 <- p3 + geom_line(data = d, linetype = \"dashed\")\n\n  # Plots ABP, if corresponds\n  dabp <- data.frame(\n    Time = ABP.time,\n    Signal = ABP.signal,\n    Segment = \"Normalised ABP\"\n  )\n  d <- dabp[1:(parameter.results[[\"transient.ABP.samples\"]][1]), ]\n  p3 <- p3 + geom_line(data = d, linetype = \"dashed\")\n  d <-dabp[tail(parameter.results[[\"transient.ABP.samples\"]], 1):nrow(dabp), ]\n  p3 <- p3 + geom_line(data = d, linetype = \"dashed\")\n\n  # Plots ABP transient segment\n  d <- dabp[parameter.results[[\"transient.ABP.samples\"]], ]\n  p3 <- p3 + geom_line(data = d, linetype = \"11\")\n  d[[\"Signal\"]] <- parameter.results[[\"transient.ABP.line\"]]\n  d[[\"Segment\"]] <- \"Transient Line\"\n  p3 <- p3 + geom_line(data = d)\n\n  # Plots CBFV transient segment\n  d <- dcbfv[parameter.results[[\"transient.CBFV.samples\"]], ]\n  p3 <- p3 + geom_line(data = d, linetype = \"11\")\n  d[[\"Signal\"]] <- parameter.results[[\"transient.CBFV.line\"]]\n  d[[\"Segment\"]] <- \"Transient Line\"\n  p3 <- p3 + geom_line(data = d)\n\n  # Plots CBFV steady segment\n  d <- dcbfv[parameter.results[[\"steady.CBFV.samples\"]], ]\n  d[[\"Signal\"]] <- parameter.results[[\"steady.CBFV.line\"]]\n  d[[\"Segment\"]] <- \"Steady Line\"\n  p3 <- p3 + geom_line(data = d, linetype = \"dashed\")\n\n  # Plots and annotates Delta Tau\n  s2 <- parameter.results[[\"transient.CBFV.samples\"]]\n  d2 <- dcbfv[s2, ]\n  y2 <- min(d2[[\"Signal\"]], na.rm = TRUE)\n  tini2 <- CBFV.time[s2[1]]\n  tfin2 <- CBFV.time[tail(s2, 1)]\n  tini1 <- ABP.time > tini2 - time.tol\n  tfin1 <- ABP.time < tfin2 + time.tol\n  s1 <- which(tini1 & tfin1)\n  d1 <- dabp[s1, ]\n  y1 <- min(d1[[\"Signal\"]], na.rm = TRUE)\n  y <- min(y1, y2)\n  d2[[\"Signal\"]] <- y - 2 * dy\n  d2[[\"Segment\"]] <- \"Transient Line\"\n  p3 <- p3 + geom_line(data = d2)\n  m <- round(nrow(d2) / 2)\n  d <- d2[m, ]\n  d[[\"Signal\"]] <- d[[\"Signal\"]] - dy\n  s <- paste(\n    \"Delta*tau\",\n    \"==\",\n    sprintf(\"%.1f\", parameter.results[[\"Delta.tau\"]])\n  )\n  d <- cbind(d, Text = s)\n  p3 <- p3 + geom_text(\n    data = d,\n    mapping = aes(label = Text),\n    size = 3,\n    hjust = 0.4,\n    vjust = 1,\n    parse = TRUE\n  )\n\n  # Annotates Ks\n  d2 <- dcbfv[parameter.results[[\"steady.CBFV.samples\"]], ]\n  i <- d2[[\"Signal\"]] < parameter.results[[\"Ks\"]]\n  d2[[\"Signal\"]] <- parameter.results[[\"Ks\"]]\n  d2[[\"Segment\"]] <- \"Steady Line\"\n  p3 <- p3 + geom_line(data = d2)\n  u <- 2 * dy\n  vjust <- 0\n  if(sum(i) - sum(!i) < 0)\n  {\n    u <- -u\n    vjust <- 1 - vjust\n  }\n  m <- round(nrow(d2) / 2)\n  d <- d2[m, ]\n  d[[\"Signal\"]] <- d[[\"Signal\"]] + u\n  s <- paste(\"K[s]\", \"==\", sprintf(\"%.4f\", parameter.results[[\"Ks\"]]))\n  d <- cbind(d, Text = s)\n  p3 <- p3 + geom_text(\n    data = d,\n    mapping = aes(label = Text),\n    size = 3,\n    hjust = 0.5,\n    vjust = vjust,\n    parse = TRUE\n  )\n\n  # Plots and annotates Phi\n  d1 <- dabp[parameter.results[[\"transient.ABP.samples\"]], ]\n  d1[[\"Signal\"]] <- parameter.results[[\"transient.ABP.line\"]]\n  d2 <- dcbfv[parameter.results[[\"transient.CBFV.samples\"]], ]\n  d2[[\"Signal\"]] <- parameter.results[[\"transient.CBFV.line\"]]\n  m <- round(min(nrow(d1), nrow(d2)) * 0.8)\n  #d <- rbind(d1[m, ], d2[m, ])\n  #d[[\"Segment\"]] <- \"Angle\"\n  #p3 <- p3 + geom_point(data = d)\n  r <- d1[[\"Time\"]][m]\n  tt <- seq(-90, 90, length.out = 100)\n  xx <- r * cos(tt * pi / 180)\n  yy <- (sin(tt * pi / 180) + 1) / 2\n  yy <- sin(tt * pi / 180)\n  #d <- data.frame(Time = xx, Signal = yy, Segment = \"Angle\")\n  #p3 <- p3 + geom_path(data = d, linetype = \"dotted\")\n  .dist <- function(x, y) sqrt((x - xx)^2 + (y - yy)^2)\n  .tmp.fun <- function(x, y) min(.dist(x, y))\n  s1 <- mapply(.tmp.fun, d1[[\"Time\"]], d1[[\"Signal\"]])\n  s1 <- which.min(s1)\n  s2 <- mapply(.tmp.fun, d2[[\"Time\"]], d2[[\"Signal\"]])\n  s2 <- which.min(s2)\n  t1 <- ABP.time[parameter.results[[\"transient.ABP.samples\"]][s1]]\n  t2 <- CBFV.time[parameter.results[[\"transient.CBFV.samples\"]][s2]]\n  y1 <- parameter.results[[\"transient.ABP.line\"]][s1]\n  y2 <- parameter.results[[\"transient.CBFV.line\"]][s2]\n  #d <- data.frame(Time = c(t1, t2), Signal = c(y1, y2), Segment = \"BLA\")\n  #p3 <- p3 + geom_point(data = d)\n  i <- yy < max(y1, y2)\n  j <- yy > min(y1, y2)\n  d <- data.frame(\n    Time = xx[i & j],\n    Signal = yy[i & j],\n    Segment = \"Angle\"\n  )\n  p3 <- p3 + geom_path(data = d, linetype = \"11\")\n\n  i <- yy < max(y1, y2) & yy < 1\n  j <- yy > min(y1, y2) & yy > 0\n  if(sum(i & j) > 0)\n  {\n    xx <- xx[i & j]\n    yy <- yy[i & j]\n    d <- data.frame(Time = xx, Signal = yy, Segment = \"Angle\")\n    p3 <- p3 + geom_path(data = d)\n  }\n  m <- round(nrow(d) / 2)\n  d <- d[m, ]\n  d[[\"Time\"]] <- d[[\"Time\"]] + dx\n  s <- paste(\n    \"varphi\",\n    \"==\",\n    sprintf(\"%.2f*degree\", parameter.results[[\"Phi\"]])\n  )\n  d <- cbind(d, Text = s)\n  p3 <- p3 + geom_text(\n    data = d,\n    mapping = aes(label = Text),\n    size = 3,\n    hjust = 0,\n    vjust = 0.5,\n    parse = TRUE\n  )\n\n  p3 <- p3 + xlab(\"Time\") + ylab(\"Normalised Signals\")\n  cmatch2 <- c(\n    \"Normalised ABP\" = abp.palette[4],\n    \"Normalised CBFV\" = cbfv.palette[4],\n    \"Transient Line\" = ann.palette[2],\n    \"Steady Line\" = ann.palette[3],\n    \"Angle\" = ann.palette[4]\n  )\n  p3 <- p3 + scale_colour_manual(\n    values = cmatch2,\n    breaks = names(cmatch2)\n  )\n  p3 <- p3 + theme(\n    legend.justification = c(0, 0),\n    legend.background = element_rect(fill = alpha('grey90', 0.0)),\n    legend.position = c(0, 0),\n    legend.key.size =  unit(0.4, \"cm\"),\n    legend.title = element_text(size = 7),\n    legend.text = element_text(size = 6)\n  )\n  p3 <- p3 +  coord_cartesian(\n    xlim = c(time.ini, time.fin),\n    ylim = c(min.normalised.intensity, max.normalised.intensity)\n  )\n\n  #\n  # Joins plots\n  #\n\n  main <- NULL\n  if(!is.null(parameter.results[[\"mfARI\"]]))\n    main <- sprintf(\"mfARI = %.1f\", parameter.results[[\"mfARI\"]])\n  else\n    if(!is.null(index.estimation.function))\n    {\n      mfari <- index.estimation.function(\n        Ks = parameter.results[[\"Ks\"]],\n        Delta.tau = parameter.results[[\"Delta.tau\"]],\n        Phi = parameter.results[[\"Phi\"]]\n      )\n      main <- sprintf(\"estimated mfARI = %.1f\", mfari)\n    }\n\n  if(!is.null(id))\n    if(is.null(main))\n      main <- id\n    else\n      main <- paste(id, main, sep = \", \")\n\n  p <- arrangeGrob(\n    arrangeGrob(p1, p2, nrow = 2),\n    p3,\n    nrow = 2,\n    main = main\n  )\n\n  p\n}\n\n#' Descripción de la función\n#' Estimates the MSE for specified duration of the transient CBFV signal\n#' In this version, Ks is the value of the normalised CBFV at the end\n#' of the transient period.\n#\n#' Would be better to limit the CBFV angle here?\n#' This would affect the slope and straight line,\n#' affecting the transient MSE...\n#'\n#' @param\n#' @return Returns a plot with the CBFV parameters for a specific Delta-Tau.\n#'\n#' @export\nestimate.mfARI.CBFV.parameters.type.2 <- function(\n      time.instants,\n      normalised.CBFV.signal,\n      min.CBFV.sample,\n      min.CBFV.time.instant,\n      transient.CBFV.duration,\n      steady.CBFV.duration,\n      time.tol = min(diff(time.instants)) / 100,\n      ...\n      )\n{\n  ans <- list()\n\n  ans[[\"Delta.tau\"]] <- transient.CBFV.duration\n  ans[[\"tau\"]] <- min.CBFV.time.instant + transient.CBFV.duration\n  ans[[\"transient.CBFV.samples\"]] <- which(\n    time.instants >= min.CBFV.time.instant - time.tol &\n    time.instants <= ans[[\"tau\"]] + time.tol\n  )\n  ans[[\"transient.CBFV.time.instants\"]] <-\n    time.instants[ans[[\"transient.CBFV.samples\"]]]\n  ans[[\"transient.normalised.CBFV.signal\"]] <-\n    normalised.CBFV.signal[ans[[\"transient.CBFV.samples\"]]]\n  ans[[\"transient.CBFV.slope\"]] <-\n    mean(ans[[\"transient.normalised.CBFV.signal\"]]) /\n    mean(ans[[\"transient.CBFV.time.instants\"]] - min.CBFV.time.instant)\n  ans[[\"transient.CBFV.line\"]] <-\n    ans[[\"transient.CBFV.slope\"]] *\n    (time.instants[ans[[\"transient.CBFV.samples\"]]] -\n     min.CBFV.time.instant)\n  if(length(ans[[\"transient.normalised.CBFV.signal\"]]) > 0)\n   # ans[[\"transient.CBFV.MSE\"]] <- get.MSE(\n    ans[[\"transient.CBFV.MSE\"]] <- mse(\n      sim = ans[[\"transient.CBFV.line\"]],\n      obs = ans[[\"transient.normalised.CBFV.signal\"]]\n    )\n  else\n    ans[[\"transient.CBFV.MSE\"]] <- Inf\n\n  ans[[\"Ks\"]] <- tail(ans[[\"transient.normalised.CBFV.signal\"]], 1)\n  ans[[\"nominal.steady.CBFV.duration\"]] <- steady.CBFV.duration\n  ans[[\"steady.CBFV.samples\"]] <- which(\n    time.instants >= ans[[\"tau\"]] - time.tol &\n    time.instants <= ans[[\"tau\"]] + steady.CBFV.duration + time.tol\n  )\n  ans[[\"steady.CBFV.time.instants\"]] <-\n    time.instants[ans[[\"steady.CBFV.samples\"]]]\n  steady.CBFV.length <- length(ans[[\"steady.CBFV.samples\"]])\n  ans[[\"steady.CBFV.duration\"]] <-\n    ans[[\"steady.CBFV.time.instants\"]][length(ans[[\"steady.CBFV.time.instants\"]])] -\n    ans[[\"tau\"]]\n  ans[[\"steady.normalised.CBFV.signal\"]] <-\n    normalised.CBFV.signal[ans[[\"steady.CBFV.samples\"]]]\n  ans[[\"steady.CBFV.line\"]] <- rep(ans[[\"Ks\"]], steady.CBFV.length)\n  if(steady.CBFV.length > 0)\n    ans[[\"steady.CBFV.MSE\"]] <- mse(\n      sim = ans[[\"steady.CBFV.line\"]],\n      obs = ans[[\"steady.normalised.CBFV.signal\"]]\n    )\n  else\n    ans[[\"steady.CBFV.MSE\"]] <- Inf\n\n  ans[[\"CBFV.response.duration\"]] <-\n    ans[[\"Delta.tau\"]] +\n    ans[[\"steady.CBFV.duration\"]]\n  if(is.finite(ans[[\"transient.CBFV.MSE\"]]) &&\n     is.finite(ans[[\"steady.CBFV.MSE\"]]))\n    ans[[\"CBFV.response.MSE\"]] <-\n      (ans[[\"Delta.tau\"]] / ans[[\"CBFV.response.duration\"]]) *\n      ans[[\"transient.CBFV.MSE\"]] +\n      (ans[[\"steady.CBFV.duration\"]] / ans[[\"CBFV.response.duration\"]]) *\n      ans[[\"steady.CBFV.MSE\"]]\n  else\n    ans[[\"CBFV.response.MSE\"]] <- Inf\n\n  return(ans)\n}\n\n#' Descripción de la función\n#' Estimates the parameters and MSE for each possible duration of the\n#' transient CBFV signal.\n#\n#' Here, if the signal is too short to cover the specified maximum\n#' transient CBFV duration, this maximum is reduced (keeping the\n#' specified duration of the steady CBFV signal).\n#\n#' For equal MSE values, it prefers the one with lower transient CBFV\n#' duration.\n#' @param\n#' @return\n#'\n#' @export\nsearch.mfARI.CBFV.parameters <- function(\n      time.instants,\n      normalised.CBFV.signal,\n      min.CBFV.sample,\n      min.CBFV.time.instant,\n      min.transient.CBFV.duration,\n      max.transient.CBFV.duration,\n      steady.CBFV.duration,\n      time.tol = min(diff(time.instants)) / 100,\n      estimation.function = estimate.mfARI.CBFV.parameters.type.2,\n      keep.search.results = FALSE,\n      add.search.plots = FALSE,\n      id = NULL,\n      ...\n      )\n{\n  min.delta.tau <- min.CBFV.time.instant + min.transient.CBFV.duration\n  max.delta.tau <- min.CBFV.time.instant + max.transient.CBFV.duration\n  last.time <- max.delta.tau + steady.CBFV.duration\n  last.instant <-time.instants[length(time.instants)]\n  if(last.time > last.instant + time.tol)\n  {\n    last.time <- last.instant\n    max.delta.tau <- last.time - steady.CBFV.duration\n    max.transient.CBFV.duration <- max.delta.tau - min.CBFV.time.instant\n    if(is.null(id))\n      msg <- \"Warning: signal is too short for specified parameters;\"\n    else\n      msg <- sprintf(\n        \"Warning: signal is too short for specified parameters (%s);\",\n        id\n      )\n    msg <- paste(\n      msg,\n      \"maximum transient CBFV signal duration was reduced to\")\n    msg <- paste(\n      msg,\n      sprintf('%.1f seconds', max.transient.CBFV.duration)\n    )\n    warning(msg)\n  }\n  i <- which(\n    time.instants >= min.delta.tau - time.tol &\n    time.instants <= max.delta.tau + time.tol\n  )\n\n  ans <- list()\n  ans[[\"Delta.tau.values\"]] <- time.instants[i] - min.CBFV.time.instant\n\n  plots <- list()\n  results <- list()\n  best.result <- list(CBFV.response.MSE = Inf)\n\n  for(delta.tau in ans[[\"Delta.tau.values\"]])\n  {\n    current.estimation <- estimation.function(\n      time.instants = time.instants,\n      normalised.CBFV.signal = normalised.CBFV.signal,\n      min.CBFV.sample = min.CBFV.sample,\n      min.CBFV.time.instant = min.CBFV.time.instant,\n      transient.CBFV.duration = delta.tau,\n      steady.CBFV.duration = steady.CBFV.duration,\n      time.tol = time.tol,\n      ...\n    )\n\n    if(current.estimation[[\"CBFV.response.MSE\"]] <\n       best.result[[\"CBFV.response.MSE\"]])\n      best.result <- current.estimation\n\n    str.delta.tau <- as.character(delta.tau)\n    if(keep.search.results)\n    {\n      lce <- list(current.estimation)\n      names(lce) <- str.delta.tau\n      results <- c(results, lce)\n    }\n\n    if(add.search.plots)\n    {\n      p <- get.plot.CBFV.parameters.search(\n        time.instants,\n        normalised.CBFV.signal,\n        min.CBFV.sample,\n        min.CBFV.time.instant,\n        current.estimation,\n        id = id,\n        ...\n      )\n      lp <- list(p)\n      names(lp) <- str.delta.tau\n      plots <- c(plots, lp)\n    }\n  }\n\n  if(keep.search.results)\n    ans[[\"search.results\"]] <- results\n\n  if(add.search.plots)\n    ans[[\"search.plots\"]] <- plots\n\n  ans <- c(ans, best.result)\n\n  return(ans)\n}\n\n#' Descripción de la función\n#' @param\n#' @return\n#'\n#' @export\nnormalise.ABP.signal <- function(\n      time.instants,\n      ABP.signal,\n      sample.release,\n      sampling.time,\n      baseline.initial.time = time.instants[1],\n      baseline.final.time = time.instants[sample.release],\n      min.ABP.max.delta.time = 5 * 0.8,\n      time.tol = sampling.time / 100\n      )\n{\n  ans <- list()\n  valid <- !is.na(ABP.signal)\n  time.release <- time.instants[sample.release]\n\n  # Adds baseline data to answer\n  if(baseline.final.time < baseline.initial.time)\n    stop(\"final time for the ABP baseline cannot be \",\n         \"before its initial time\")\n  if(baseline.final.time > time.release)\n    stop(\"final time for the ABP baseline cannot be \",\n         \"after the release of the thigh cuffs\")\n\n\ti <- which(valid & time.instants >= baseline.initial.time - time.tol)\n  if(length(i) == 0)\n    stop(\"no time instant for the beginning of the ABP baseline could be determined\")\n\ti <- i[1]\n  ans[[\"ABP.baseline.initial.time\"]] <- time.instants[i]\n  ans[[\"ABP.baseline.initial.sample\"]] <- i\n\n\ti <- which(valid & time.instants <= baseline.final.time + time.tol)\n  if(length(i) == 0)\n    stop(\"no time instant for the end of the ABP baseline could be determined\")\n\ti <- tail(i, 1)\n  ans[[\"ABP.baseline.final.time\"]] <- time.instants[i]\n  ans[[\"ABP.baseline.final.sample\"]] <- i\n\n\tans[[\"ABP.baseline.samples\"]] <-\n    ans[[\"ABP.baseline.initial.sample\"]]:ans[[\"ABP.baseline.final.sample\"]]\n\tans[[\"ABP.baseline.duration\"]] <-\n    ans[[\"ABP.baseline.final.time\"]] - ans[[\"ABP.baseline.initial.time\"]]\n  ans[[\"ABP.baseline.value\"]] <- mean(\n    ABP.signal[ans[[\"ABP.baseline.samples\"]]],\n    na.rm = TRUE\n  )\n\n  # Sets min ABP window\n  ans[[\"min.ABP.max.delta.time\"]] <- min.ABP.max.delta.time\n  i <- time.instants > time.release + time.tol\n  j <- time.instants < time.release + ans[[\"min.ABP.max.delta.time\"]] +\n       time.tol\n  ans[[\"min.ABP.samples\"]] <- which(valid & i & j)\n  if(length(ans[[\"min.ABP.samples\"]]) == 0)\n    stop(\"no candidates for min ABP\")\n\n  # Gets minimum ABP\n  ans[[\"min.ABP.window\"]] <- ABP.signal[ans[[\"min.ABP.samples\"]]]\n  min.sample.in.window <- which.min(ans[[\"min.ABP.window\"]])\n  min.ABP.sample <- min.sample.in.window + ans[[\"min.ABP.samples\"]][1] - 1\n  ans[[\"min.ABP.time.instant\"]] <- time.instants[min.ABP.sample]\n  ans[[\"min.ABP.sample\"]] <- min.ABP.sample\n  ans[[\"min.ABP.value\"]] <- ABP.signal[min.ABP.sample]\n\n  # Gets min ABP type\n  min.info <- findpeaks(\n    -ans[[\"min.ABP.window\"]],\n    zero = \"-\",\n    sortstr = TRUE\n  )\n  ans[[\"min.ABP.type\"]] <- \"minimum value in window\"\n  if(!is.null(min.info) && min.info[1, 2] == min.sample.in.window)\n    ans[[\"min.ABP.type\"]] <- \"local minimum\"\n\n  # Measures min ABP drop\n  ans[[\"min.ABP.drop\"]] <-\n    ans[[\"ABP.baseline.value\"]] - ans[[\"min.ABP.value\"]]\n  ans[[\"min.ABP.drop.pc\"]] <-\n    ans[[\"min.ABP.drop\"]] / ans[[\"ABP.baseline.value\"]]\n  ans[[\"min.ABP.drop.pc\"]] <- round(ans[[\"min.ABP.drop.pc\"]] * 100, 2)\n\n  # Normalises the signal\n  ans[[\"normalised.ABP.signal\"]] <- normalise.signal(\n    signal = ABP.signal,\n    signal.baseline.value = ans[[\"ABP.baseline.value\"]],\n    signal.min.value = ans[[\"min.ABP.value\"]]\n  )\n\n  invisible(ans)\n}\n\n#' Descripción de la función\n#' @param\n#' @return\n#'\n#' @export\nnormalise.CBFV.signal <- function(\n      time.instants,\n      CBFV.signal,\n      sample.release,\n      sampling.time,\n      baseline.initial.time = time.instants[1],\n      baseline.final.time = time.instants[sample.release],\n      min.CBFV.max.delta.time = 8 * 0.8,\n      time.tol = sampling.time / 100\n      )\n{\n  ans <- list()\n  valid <- !is.na(CBFV.signal)\n  time.release <- time.instants[sample.release]\n\n  # Adds baseline data to answer\n  if(baseline.final.time < baseline.initial.time)\n    stop(\"final time for the CBFV baseline cannot be before its initial time\")\n  if(baseline.final.time > time.release)\n    stop(\"final time for the CBFV baseline cannot be after the release of the thigh cuffs\")\n\n\ti <- which(valid & time.instants >= baseline.initial.time - time.tol)\n  if(length(i) == 0)\n    stop(\"no time instant for the beginning of the CBFV baseline could be determined\")\n\ti <- i[1]\n  ans[[\"CBFV.baseline.initial.time\"]] <- time.instants[i]\n  ans[[\"CBFV.baseline.initial.sample\"]] <- i\n\n\ti <- which(valid & time.instants <= baseline.final.time + time.tol)\n  if(length(i) == 0)\n    stop(\"no time instant for the end of the CBFV baseline could be determined\")\n\ti <- tail(i, 1)\n  ans[[\"CBFV.baseline.final.time\"]] <- time.instants[i]\n  ans[[\"CBFV.baseline.final.sample\"]] <- i\n\n\tans[[\"CBFV.baseline.samples\"]] <- ans[[\"CBFV.baseline.initial.sample\"]]:ans[[\"CBFV.baseline.final.sample\"]]\n\tans[[\"CBFV.baseline.duration\"]] <- ans[[\"CBFV.baseline.final.time\"]] - ans[[\"CBFV.baseline.initial.time\"]]\n\n  # Gets baseline value\n  ans[[\"CBFV.baseline.value\"]] <- mean(CBFV.signal[ans[[\"CBFV.baseline.samples\"]]], na.rm = TRUE)\n\n  # Sets min CBFV window\n  ans[[\"min.CBFV.max.delta.time\"]] <- min.CBFV.max.delta.time\n  i <- time.instants > time.release + time.tol\n  j <- time.instants < time.release + ans[[\"min.CBFV.max.delta.time\"]] +\n       time.tol\n  ans[[\"min.CBFV.samples\"]] <- which(valid & i & j)\n  if(length(ans[[\"min.CBFV.samples\"]]) == 0)\n    stop(\"no candidates for min CBFV\")\n\n  # Gets minimum CBFV\n  ans[[\"min.CBFV.window\"]] <- CBFV.signal[ans[[\"min.CBFV.samples\"]]]\n  min.sample.in.window <- which.min(ans[[\"min.CBFV.window\"]])\n  min.CBFV.sample <- min.sample.in.window + ans[[\"min.CBFV.samples\"]][1] - 1\n  ans[[\"min.CBFV.time.instant\"]] <- time.instants[min.CBFV.sample]\n  ans[[\"min.CBFV.sample\"]] <- min.CBFV.sample\n  ans[[\"min.CBFV.value\"]] <- CBFV.signal[min.CBFV.sample]\n\n  # Gets min CBFV type\n  min.info <- findpeaks(\n    -ans[[\"min.CBFV.window\"]],\n    zero = \"-\",\n    sortstr = TRUE\n  )\n  ans[[\"min.CBFV.type\"]] <- \"minimum value in window\"\n  if(!is.null(min.info) && min.info[1, 2] == min.sample.in.window)\n    ans[[\"min.CBFV.type\"]] <- \"local minimum\"\n\n  # Normalises the signal\n  ans[[\"normalised.CBFV.signal\"]] <- normalise.signal(\n    signal = CBFV.signal,\n    signal.baseline.value = ans[[\"CBFV.baseline.value\"]],\n    signal.min.value = ans[[\"min.CBFV.value\"]]\n  )\n\n  invisible(ans)\n}\n\n#' Descripción de la función\n#' @param\n#' @return\n#'\n#' @export\nget.mfARI.parameters <- function(\n      time.instants,\n      ABP.signal,\n      CBFV.signal,\n      sampling.time,\n      time.release,\n      baseline.initial.time = time.instants[1],\n      baseline.final.time = time.release,\n      min.ABP.max.delta.time = 5 * 0.8,\n      transient.ABP.duration = 6,\n      min.CBFV.max.delta.time = 8 * 0.8,\n      min.transient.CBFV.duration = 1.5,\n      max.transient.CBFV.duration = 10,\n      steady.CBFV.duration = 6,\n      min.Ks = 0.0,\n      max.Ks = 1.022095,\n      min.ABP.angle = 0.0,\n      max.ABP.angle = 90.0,\n      min.CBFV.angle = 0.0,\n      max.CBFV.angle = 90.0,\n      min.Phi = 0.0,\n      max.Phi = 35.238932,\n      keep.details = TRUE,\n      ABP.rounding.digits = 2,\n      normalised.ABP.rounding.digits = ABP.rounding.digits * 2,\n      CBFV.rounding.digits = 2,\n      normalised.CBFV.rounding.digits = CBFV.rounding.digits * 2,\n      Ks.rounding.digits = 4,\n      Phi.rounding.digits = 2,\n      time.tol = sampling.time / 100,\n      ... # Passed to search.mfARI.CBFV.parameters\n      )\n{\n  # Simple validations\n  if(transient.ABP.duration < sampling.time)\n    stop(\"duration of the transient ABP signal is too short\")\n  if(steady.CBFV.duration < sampling.time)\n    stop(\"duration of the steady CBFV signal is too short\")\n  if(max.transient.CBFV.duration < min.transient.CBFV.duration)\n    stop(\"maximum duration of the transient CBFV signal must be equal or higher than the specified minimum duration\")\n  if(max.Ks < min.Ks)\n    stop(\"maximum value for Ks must be equal or higher than the specified minimum value\")\n  if(max.ABP.angle < min.ABP.angle)\n    stop(\"maximum value for the ABP recovery angle must be equal or higher than the specified minimum value\")\n  if(max.CBFV.angle < min.CBFV.angle)\n    stop(\"maximum value for the CBFV recovery angle must be equal or higher than the specified minimum value\")\n  if(max.Phi < min.Phi)\n    stop(\"maximum value for the difference between ABP and CBFV recovery angles must be equal or higher than the specified minimum value\")\n\n  # Validates the lengths of the signals\n  if(length(ABP.signal) != length(CBFV.signal))\n    stop(\"ABP and CBFV signals must be of the same length\")\n  if(length(ABP.signal) != length(time.instants))\n    stop(\"number of time instants must coincide with the signals\")\n\n  # Validates sampling time\n  if(sampling.time < 0.1 - time.tol)\n    stop(\"sampling time must be equal or higher than 0.1\")\n\n  # Defines the detailed answer list\n  dans <- list()\n\n  # Copies the original signals\n\tdans[[\"time.instants\"]] <- round(time.instants, 1)\n\tdans[[\"ABP.signal\"]] <- round(ABP.signal, ABP.rounding.digits)\n\tdans[[\"CBFV.signal\"]] <- round(CBFV.signal, CBFV.rounding.digits)\n\n  # Sets frequency\n\tdans[[\"sampling.time\"]] <- round(sampling.time, 1)\n\tdans[[\"frequency\"]] <- 1 / sampling.time\n\n  # Sets release sample\n\tdans[[\"time.release\"]] <- time.release\n  i <- which(are.tolerably.equal(time.instants, time.release, time.tol))\n  if(length(i) != 1)\n    stop(\"a unique time instant for the thigh-cuff release could not be determined\")\n  dans[[\"sample.release\"]] <- i\n  if(!is.finite(ABP.signal[i]))\n    stop(\"invalid ABP signal value at the time of thigh-cuff release\")\n  if(!is.finite(CBFV.signal[i]))\n    stop(\"invalid CBFV signal value at the time of thigh-cuff release\")\n\n  # Normalises ABP\n  nabp <- normalise.ABP.signal(\n    time.instants = dans[[\"time.instants\"]],\n    ABP.signal = dans[[\"ABP.signal\"]],\n    sample.release = dans[[\"sample.release\"]],\n    sampling.time = dans[[\"sampling.time\"]],\n    baseline.initial.time = baseline.initial.time,\n    baseline.final.time = baseline.final.time,\n    min.ABP.max.delta.time = min.ABP.max.delta.time,\n    time.tol = time.tol\n  )\n  nabp[[\"normalised.ABP.signal\"]] <- round(\n    nabp[[\"normalised.ABP.signal\"]],\n    normalised.ABP.rounding.digits\n  )\n  dans <- c(dans, nabp)\n\n  # Normalises CBFV\n  ncbfv <- normalise.CBFV.signal(\n    time.instants = dans[[\"time.instants\"]],\n    CBFV.signal = dans[[\"CBFV.signal\"]],\n    sample.release = dans[[\"sample.release\"]],\n    sampling.time = dans[[\"sampling.time\"]],\n    baseline.initial.time = baseline.initial.time,\n    baseline.final.time = baseline.final.time,\n    min.CBFV.max.delta.time = min.CBFV.max.delta.time,\n    time.tol = time.tol\n  )\n  ncbfv[[\"normalised.CBFV.signal\"]] <- round(\n    ncbfv[[\"normalised.CBFV.signal\"]],\n    normalised.CBFV.rounding.digits\n  )\n  dans <- c(dans, ncbfv)\n\n  if(any(nabp[[\"ABP.baseline.samples\"]] != ncbfv[[\"CBFV.baseline.samples\"]]))\n    warning(\"baseline samples are different for ABP and CBFV\")\n\n  # Search for best Ks and delta-tau\n  search.results <- search.mfARI.CBFV.parameters(\n    time.instants = time.instants,\n    normalised.CBFV.signal = dans[[\"normalised.CBFV.signal\"]],\n    min.CBFV.sample = dans[[\"min.CBFV.sample\"]],\n    min.CBFV.time.instant = dans[[\"min.CBFV.time.instant\"]],\n    min.transient.CBFV.duration = min.transient.CBFV.duration,\n    max.transient.CBFV.duration = max.transient.CBFV.duration,\n    steady.CBFV.duration = steady.CBFV.duration,\n    time.tol = time.tol,\n    ...)\n  dans <- c(dans, search.results)\n\n  dans[[\"Delta.tau\"]] <- round(dans[[\"Delta.tau\"]], 1)\n\n  # Bounds Ks parameter\n  if(dans[[\"Ks\"]] < min.Ks)\n    dans[[\"Ks\"]] <- min.Ks\n  if(dans[[\"Ks\"]] > max.Ks)\n    dans[[\"Ks\"]] <- max.Ks\n  dans[[\"Ks\"]] <- round(dans[[\"Ks\"]], Ks.rounding.digits)\n\n  # Gets transient ABP representation\n  dans[[\"nominal.transient.ABP.duration\"]] <- transient.ABP.duration\n  nominal.transient.ABP.end.time <- dans[[\"min.ABP.time.instant\"]] + transient.ABP.duration\n  dans[[\"transient.ABP.samples\"]] <- which(time.instants >= dans[[\"min.ABP.time.instant\"]] & time.instants <= nominal.transient.ABP.end.time)\n  dans[[\"transient.ABP.time.instants\"]] <- time.instants[dans[[\"transient.ABP.samples\"]]]\n  dans[[\"transient.ABP.duration\"]] <- dans[[\"transient.ABP.time.instants\"]][length(dans[[\"transient.ABP.time.instants\"]])] - dans[[\"min.ABP.time.instant\"]]\n  dans[[\"transient.normalised.ABP.signal\"]] <- dans[[\"normalised.ABP.signal\"]][dans[[\"transient.ABP.samples\"]]]\n  dans[[\"transient.ABP.slope\"]] <- mean(dans[[\"transient.normalised.ABP.signal\"]]) / mean(dans[[\"transient.ABP.time.instants\"]] - dans[[\"min.ABP.time.instant\"]])\n  dans[[\"transient.ABP.line\"]] <- dans[[\"transient.ABP.slope\"]] * (time.instants[dans[[\"transient.ABP.samples\"]]] - dans[[\"min.ABP.time.instant\"]])\n\n  # Gets transient ABP angle\n  dans[[\"transient.ABP.angle\"]] <- atan(dans[[\"transient.ABP.slope\"]]) * 180 / pi\n  dans[[\"bounded.transient.ABP.angle\"]] <- dans[[\"transient.ABP.angle\"]]\n  if(dans[[\"bounded.transient.ABP.angle\"]] < min.ABP.angle)\n    dans[[\"bounded.transient.ABP.angle\"]] <- min.ABP.angle\n  if(dans[[\"bounded.transient.ABP.angle\"]] > max.ABP.angle)\n    dans[[\"bounded.transient.ABP.angle\"]] <- max.ABP.angle\n\n  # Gets transient CBFV angle\n  dans[[\"transient.CBFV.angle\"]] <- atan(dans[[\"transient.CBFV.slope\"]]) * 180 / pi\n  dans[[\"bounded.transient.CBFV.angle\"]] <- dans[[\"transient.CBFV.angle\"]]\n  if(dans[[\"bounded.transient.CBFV.angle\"]] < min.CBFV.angle)\n    dans[[\"bounded.transient.CBFV.angle\"]] <- min.CBFV.angle\n  if(dans[[\"bounded.transient.CBFV.angle\"]] > max.CBFV.angle)\n    dans[[\"bounded.transient.CBFV.angle\"]] <- max.CBFV.angle\n\n  # Gets Phi parameter\n  dans[[\"transient.angles.difference\"]] <- dans[[\"transient.CBFV.angle\"]] - dans[[\"transient.ABP.angle\"]]\n  dans[[\"bounded.transient.angles.difference\"]] <- dans[[\"bounded.transient.CBFV.angle\"]] - dans[[\"bounded.transient.ABP.angle\"]]\n  dans[[\"Phi\"]] <- dans[[\"bounded.transient.angles.difference\"]]\n  if(dans[[\"Phi\"]] < min.Phi)\n    dans[[\"Phi\"]] <- min.Phi\n  if(dans[[\"Phi\"]] > max.Phi)\n    dans[[\"Phi\"]] <- max.Phi\n  dans[[\"Phi\"]] <- round(dans[[\"Phi\"]], Phi.rounding.digits)\n\n  if(!keep.details)\n  {\n    ans <- list()\n\n    ans[[\"ABP.baseline.samples\"]] <- dans[[\"ABP.baseline.samples\"]]\n    ans[[\"ABP.baseline.value\"]] <- dans[[\"ABP.baseline.value\"]]\n\n    ans[[\"min.ABP.samples\"]] <- dans[[\"min.ABP.samples\"]]\n    ans[[\"min.ABP.sample\"]] <- dans[[\"min.ABP.sample\"]]\n    ans[[\"min.ABP.value\"]] <- dans[[\"min.ABP.value\"]]\n    ans[[\"min.ABP.type\"]] <- dans[[\"min.ABP.type\"]]\n    ans[[\"min.ABP.drop.pc\"]] <- dans[[\"min.ABP.drop.pc\"]]\n\n    ans[[\"CBFV.baseline.samples\"]] <- dans[[\"CBFV.baseline.samples\"]]\n    ans[[\"CBFV.baseline.value\"]] <- dans[[\"CBFV.baseline.value\"]]\n\n    ans[[\"min.CBFV.samples\"]] <- dans[[\"min.CBFV.samples\"]]\n    ans[[\"min.CBFV.sample\"]] <- dans[[\"min.CBFV.sample\"]]\n    ans[[\"min.CBFV.value\"]] <- dans[[\"min.CBFV.value\"]]\n    ans[[\"min.CBFV.type\"]] <- dans[[\"min.CBFV.type\"]]\n\n    ans[[\"normalised.ABP.signal\"]] <- dans[[\"normalised.ABP.signal\"]]\n    ans[[\"normalised.CBFV.signal\"]] <- dans[[\"normalised.CBFV.signal\"]]\n\n    ans[[\"transient.ABP.samples\"]] <- dans[[\"transient.ABP.samples\"]]\n    ans[[\"transient.ABP.slope\"]] <- dans[[\"transient.ABP.slope\"]]\n    ans[[\"transient.ABP.line\"]] <- dans[[\"transient.ABP.line\"]]\n\n    ans[[\"transient.CBFV.samples\"]] <- dans[[\"transient.CBFV.samples\"]]\n    ans[[\"transient.CBFV.slope\"]] <- dans[[\"transient.CBFV.slope\"]]\n    ans[[\"transient.CBFV.line\"]] <- dans[[\"transient.CBFV.line\"]]\n    ans[[\"steady.CBFV.samples\"]] <- dans[[\"steady.CBFV.samples\"]]\n    ans[[\"steady.CBFV.line\"]] <- dans[[\"steady.CBFV.line\"]]\n    ans[[\"steady.CBFV.duration\"]] <- dans[[\"steady.CBFV.duration\"]]\n\n    ans[[\"Delta.tau\"]] <- dans[[\"Delta.tau\"]]\n    ans[[\"Ks\"]] <- dans[[\"Ks\"]]\n    ans[[\"Phi\"]] <- dans[[\"Phi\"]]\n  }\n  else\n    ans <- dans\n\n  invisible(ans)\n}\n\n#' Descripción de la función\n#' @param\n#' @return\n#'\n#' @export\nget.unbounded.mfARI.parameters.for.AT.decimal <- function()\n{\n  sampling.time <- 0.1\n  time.until.release <- 10\n  time.after.release <- 20\n  smooth.step.stimulus <- FALSE\n  filter.order <- 2\n  cutoff.frequency <- 0.20\n  left.stabilisation.time <- ifelse(smooth.step.stimulus, 30, 0)\n  time.rounding.digits <-  1\n  stabilisation.time <- 1\n  rounding.digits <- 6\n\n  min.ABP.max.delta.time <- 5 * 0.8\n  transient.ABP.duration <- 6\n  min.CBFV.max.delta.time <- 8 * 0.8\n  min.transient.CBFV.duration <- 0.1\n  max.transient.CBFV.duration <- 20 - 6 - 0.1\n  steady.CBFV.duration <- 6\n  min.Ks <- -Inf\n  max.Ks <- Inf\n  min.ABP.angle <- -Inf\n  max.ABP.angle <- Inf\n  min.CBFV.angle <- -Inf\n  max.CBFV.angle <- Inf\n  min.Phi <- -Inf\n  max.Phi <- Inf\n\n  params <- get.AT.decimal.templates.parameters(rounding.digits = rounding.digits)\n  curves <- get.AT.decimal.templates(sampling.time = sampling.time,\n                                     time.until.release = time.until.release,\n                                     time.after.release = time.after.release,\n                                     smooth.step.stimulus = smooth.step.stimulus,\n                                     filter.order = filter.order,\n                                     cutoff.frequency = cutoff.frequency,\n                                     left.stabilisation.time = left.stabilisation.time,\n                                     time.rounding.digits =  time.rounding.digits,\n                                     stabilisation.time = stabilisation.time,\n                                     rounding.digits = rounding.digits)\n\n  .tmp.fun <- function(i) get.mfARI.parameters(\n    time.instants = curves[[i]][[\"time.instants\"]],\n    ABP.signal = curves[[i]][[\"ABP.normalised\"]],\n    CBFV.signal = curves[[i]][[\"CBFV.step.response\"]],\n    sampling.time = curves[[i]][[\"sampling.time\"]],\n    time.release = curves[[i]][[\"time.release\"]],\n    baseline.initial.time = curves[[i]][[\"time.instants\"]][1],\n    baseline.final.time = curves[[i]][[\"time.release\"]],\n    min.ABP.max.delta.time = min.ABP.max.delta.time,\n    transient.ABP.duration = transient.ABP.duration,\n    min.CBFV.max.delta.time = min.CBFV.max.delta.time,\n    min.transient.CBFV.duration = min.transient.CBFV.duration,\n    max.transient.CBFV.duration = max.transient.CBFV.duration,\n    steady.CBFV.duration = steady.CBFV.duration,\n    min.Ks = min.Ks,\n    max.Ks = max.Ks,\n    min.ABP.angle = min.ABP.angle,\n    max.ABP.angle = max.ABP.angle,\n    min.CBFV.angle = min.CBFV.angle,\n    max.CBFV.angle = max.CBFV.angle,\n    min.Phi = min.Phi,\n    max.Phi = max.Phi,\n    rounding.digits = rounding.digits,\n    keep.details = FALSE\n  )\n  mfARI.curves <- lapply(1:length(curves), .tmp.fun)\n\n  ATARI <- params[[\"ARI\"]]\n  Ks <- sapply(mfARI.curves, function(c) c[[\"Ks\"]])\n  Delta.tau <- sapply(mfARI.curves, function(c) c[[\"Delta.tau\"]])\n  Phi <- sapply(mfARI.curves, function(c) c[[\"Phi\"]])\n\n  data.frame(ATARI, Ks, Delta.tau, Phi)\n}\n\n#' Descripción de la función\n#' @param\n#' @return\n#'\n#' @export\nget.bounds.of.mfARI.parameters.for.AT.decimal <- function()\n{\n  table <- get.unbounded.mfARI.parameters.for.AT.decimal()\n  table[[\"Delta.tau\"]][1] <- max(table[[\"Delta.tau\"]][-1])\n\n  mins <- c(min(table[[\"Ks\"]]), min(table[[\"Delta.tau\"]]), min(table[[\"Phi\"]]))\n  maxs <- c(max(table[[\"Ks\"]]), max(table[[\"Delta.tau\"]]), max(table[[\"Phi\"]]))\n\n  ans <- data.frame(matrix(c(mins, maxs), nrow = 3))\n  rownames(ans) <- c(\"Ks\", \"Delta.tau\", \"Phi\")\n  colnames(ans) <- c(\"Min\", \"Max\")\n\n  ans\n}\n\n#' Descripción de la función\n#' @param\n#' @return\n#'\n#' @export\nget.bounded.mfARI.parameters.for.AT.decimal <- function()\n{\n  sampling.time <- 0.1\n  time.until.release <- 10\n  time.after.release <- 20\n  smooth.step.stimulus <- FALSE\n  filter.order <- 2\n  cutoff.frequency <- 0.20\n  left.stabilisation.time <- ifelse(smooth.step.stimulus, 30, 0)\n  time.rounding.digits <-  1\n  stabilisation.time <- 1\n  rounding.digits <- 6\n\n  min.ABP.max.delta.time <- 5 * 0.8\n  transient.ABP.duration <- 6\n  min.CBFV.max.delta.time <- 8 * 0.8\n  min.transient.CBFV.duration <-  1.5\n  max.transient.CBFV.duration <- 10.0\n  steady.CBFV.duration <- 6\n  min.Ks <- 0.0\n  max.Ks <- 1.022095\n  min.ABP.angle <- 0\n  max.ABP.angle <- 90\n  min.CBFV.angle <- 0\n  max.CBFV.angle <- 90\n  min.Phi <- 0.0\n  max.Phi <- 35.238932\n\n  params <- get.AT.decimal.templates.parameters(rounding.digits = rounding.digits)\n  curves <- get.AT.decimal.templates(sampling.time = sampling.time,\n                                     time.until.release = time.until.release,\n                                     time.after.release = time.after.release,\n                                     smooth.step.stimulus = smooth.step.stimulus,\n                                     filter.order = filter.order,\n                                     cutoff.frequency = cutoff.frequency,\n                                     left.stabilisation.time = left.stabilisation.time,\n                                     time.rounding.digits =  time.rounding.digits,\n                                     stabilisation.time = stabilisation.time,\n                                     rounding.digits = rounding.digits)\n\n  .tmp.fun <- function(i) get.mfARI.parameters(\n    time.instants = curves[[i]][[\"time.instants\"]],\n    ABP.signal = curves[[i]][[\"ABP.normalised\"]],\n    CBFV.signal = curves[[i]][[\"CBFV.step.response\"]],\n    sampling.time = curves[[i]][[\"sampling.time\"]],\n    time.release = curves[[i]][[\"time.release\"]],\n    baseline.initial.time = curves[[i]][[\"time.instants\"]][1],\n    baseline.final.time = curves[[i]][[\"time.release\"]],\n    min.ABP.max.delta.time = min.ABP.max.delta.time,\n    transient.ABP.duration = transient.ABP.duration,\n    min.CBFV.max.delta.time = min.CBFV.max.delta.time,\n    min.transient.CBFV.duration = min.transient.CBFV.duration,\n    max.transient.CBFV.duration = max.transient.CBFV.duration,\n    steady.CBFV.duration = steady.CBFV.duration,\n    min.Ks = min.Ks,\n    max.Ks = max.Ks,\n    min.ABP.angle = min.ABP.angle,\n    max.ABP.angle = max.ABP.angle,\n    min.CBFV.angle = min.CBFV.angle,\n    max.CBFV.angle = max.CBFV.angle,\n    min.Phi = min.Phi,\n    max.Phi = max.Phi,\n    rounding.digits = rounding.digits,\n    keep.details = FALSE\n  )\n\n  n <- length(curves)\n  mfARI.curves <- lapply(1:n, .tmp.fun)\n\n  ATARI <- params[[\"ARI\"]]\n  Ks <- sapply(mfARI.curves, function(c) c[[\"Ks\"]])\n  Delta.tau <- sapply(mfARI.curves, function(c) c[[\"Delta.tau\"]])\n  Delta.tau[1] <- max.transient.CBFV.duration\n  Phi <- sapply(mfARI.curves, function(c) c[[\"Phi\"]])\n\n  data.frame(ATARI, Ks, Delta.tau, Phi)\n}\n\n#' Descripción de la función\n#' @param\n#' @return\n#'\n#' @export\nget.ATARI.mfARI.linear.relationship <- function()\n{\n  params <<- get.bounded.mfARI.parameters.for.AT.decimal()\n  model <- lm(ATARI ~ Ks + Delta.tau + Phi, data = params)\n  print(summary(model))\n\n  predictions <- stats::predict(model, newdata = params, interval = \"confidence\")\n  colnames(predictions) <- c(\"mfARI\", \"lwr\", \"upr\")\n  params <- cbind(params, predictions)\n\n  p1 <- ggplot(params, aes(x = ATARI, y = Ks))\n  p1 <- p1 + geom_line() + geom_point()\n  p2 <- ggplot(params, aes(x = ATARI, y = Delta.tau))\n  p2 <- p2 + geom_line() + geom_point()\n  p3 <- ggplot(params, aes(x = ATARI, y = Phi))\n  p3 <- p3 + geom_line() + geom_point()\n\n  i <- complete.cases(params)\n  print(params[!i])\n  print(params)\n\n  g <- ggplot(data = params, aes(x=ATARI, y = mfARI))\n  g <- g + geom_point()\n  g <- g + stat_smooth(method = \"lm\", colour = \"red\")\n  g <- g + xlim(0, 9) + ylim(0, 9)\n  p <- arrangeGrob(p1, p2, p3, g)\n  #capture.output(print(summary(m), prmsd=TRUE, digits=1))\n\n  list(model, p)\n}\n\n#' Descripción de la función\n#' @param\n#' @return\n#'\n#' @export\nget.ATARI.mfARI.linear.relationship.no.Phi <- function()\n{\n  params <<- get.bounded.mfARI.parameters.for.AT.decimal()\n  model <- lm(ATARI ~ Ks + Delta.tau, data = params)\n  print(summary(model))\n\n  predictions <- stats::predict(model, newdata = params, interval = \"confidence\")\n  colnames(predictions) <- c(\"mfARI\", \"lwr\", \"upr\")\n  params <- cbind(params, predictions)\n\n  p1 <- ggplot(params, aes(x = ATARI, y = Ks))\n  p1 <- p1 + geom_line() + geom_point()\n  p2 <- ggplot(params, aes(x = ATARI, y = Delta.tau))\n  p2 <- p2 + geom_line() + geom_point()\n  p3 <- ggplot(params, aes(x = ATARI, y = Phi))\n  p3 <- p3 + geom_line() + geom_point()\n\n  g <- ggplot(data = params, aes(x=ATARI, y = mfARI))\n  g <- g + geom_point()\n  g <- g + stat_smooth(method = \"lm\", colour = \"red\")\n  g <- g + xlim(0, 9) + ylim(0, 9)\n  p <- arrangeGrob(p1, p2, p3, g)\n  #capture.output(print(summary(m), prmsd=TRUE, digits=1))\n\n  list(model, p)\n}\n\n",
    "created" : 1476758842059.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2968028248",
    "id" : "352EF33B",
    "lastKnownWriteTime" : 1476759246,
    "last_content_update" : 1476759246963,
    "path" : "~/Documents/BecaMagister2/packages/mfARI/R/mfARI-v15.9.10.R",
    "project_path" : "R/mfARI-v15.9.10.R",
    "properties" : {
    },
    "relative_order" : 1,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}